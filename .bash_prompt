if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM='xterm-256color';
fi;

if tput setaf 1 &> /dev/null; then
  # bold=$(tput bold);
  RESET=$(tput sgr0);
  BLACK=$(tput setaf 0);
  RED=$(tput setaf 1);
  GREEN=$(tput setaf 2);
  YELLOW=$(tput setaf 3);
  BLUE=$(tput setaf 4);
  MAGENTA=$(tput setaf 5);
  CYAN=$(tput setaf 6);
  WHITE=$(tput setaf 7);
else
  # BOLD='';
  RESET="\e[0m";
  BLACK="\e[30m";
  RED="\e[31m";
  GREEN='\e[32m';
  YELLOW="\e[33m";
  BLUE="\e[34m";
  MAGENTA="\e[35m";
  CYAN="\e[36m";
  VIOLET="\e[35m";
  WHITE="\e[37m";
fi;

# Set a color for the git branch name based on its status
function git_status_color {
  local git_status="$(git status 2> /dev/null)"

  # Check if git directory is dirty
  if [[ ! $git_status =~ "working tree clean" ]]; then
    echo -e $RED

  # Check if commits need to be pushed
  elif [[ $git_status =~ "Your branch is ahead of" ]]; then
    echo -e $YELLOW

  # Check if git directory is clean
  elif [[ $git_status =~ "nothing to commit" ]]; then
    echo -e $GREEN

  else
    echo -e $WHITE
  fi
}

# Get the current git branch name
parse_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/'
}

PS1='\n';
PS1+='\[$GREEN\][\[$RESET\]';
PS1+='\[$WHITE\]\W\[$RESET\]';
PS1+='\[$(git_status_color)\]';
PS1+='$(parse_git_branch)';
PS1+='\[$RESET\]'
PS1+='\[$GREEN\]]\[$RESET\] ';
export PS1;

PS2='${yellow}> ${reset}';
export PS2;
